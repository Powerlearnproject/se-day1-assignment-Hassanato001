[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18651319&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is a branch of engineering that is associated with the development of software products that solve real-world problems using well-defined principles, methods, and procedures.
1. Making Digital Change Happen: Software engineering is what lets companies change how they do things using computers. It helps them automate stuff, work better, and make new computer programs and services they couldn't make without strong computer systems.

2. Making Sure Things Work Right: Software engineering makes sure important systems work well by doing things like keeping track of changes, testing automatically, and checking code. This is super important in fields like healthcare, flying, and money, where computer problems could cost a lot of money or even hurt people.

3. Handling Growth and Speed: As more people use technology, software engineering helps systems grow without slowing down. Good planning, making things faster, and managing resources let programs handle more users and still work well.

4. Working Together Better: New ways of doing software engineering, like Agile and DevOps, help different people work together. This helps companies come up with new ideas faster and react to what the market and users want, which gives them an edge.

5. Saving Money: When companies do software engineering the right way, they can save money on making programs. Using code again, designing things in pieces, and testing automatically cuts down on upkeep costs and makes programs last longer, so they get more for their money.

Identify and describe at least three key milestones in the evolution of software engineering.
Mastering complexity
Mastering process
Mastering machine
1. Taming Complexity
Early software development faced a challenge: programs became too complex for one person to manage. To fix this, structured and modular programming came about, later evolving into object-oriented methods. Key concepts were hiding details and standardizing design. Languages also improved, from machine code to FORTRAN, C, and Java, making it easier to handle complex code. This phase established guidelines for managing intricate software through clear structures.

2. Process Management
Next, the focus shifted to organizing teams for consistent software creation. People understood that successful software involved teamwork, planning, and standardized practices, not just coding. The Waterfall model appeared in the 70s, emphasizing documentation and sequential steps. When that didn't quite fit right, iterative approaches came about. The Agile Manifesto in 2001 prioritized flexibility, collaboration, and customer input over rigid rules. Meaning, great software requires talented folks and work methods that suit how people actually work.

3. Machine Control
Currently, software engineering centers on controlling computer systems. Cloud computing and virtualization have emerged, along with containerization for universal software deployment. There's a trend to view computers as programmable tools. DevOps combines software and IT teams, plus there are automated software release processes. Machine learning is being integrated into software, which opens new applications. Coding is only part of the job, software engineers are in charge of big networks, software releases, and system setups.

List and briefly explain the phases of the Software Development Life Cycle.
Requirement analysis: It involves gathering and documenting user needs and system requirements.
Product Design: It involves creating high-level and detailed designs for the software architecture and user interface.
Product development: it involves writing code and building the software according to the design structure.
Testing: conducting various tests to ensure quality standards and functionality.
Deployment: releasing software to users and customers.
Maintenance: Providing ongoing support, updates, and enhancement to software.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall methodology: It is the sequential and linear approach 
    While
Agile methodology: Iterative and incremental approach with multiple cycles.
Waterfall vs. Agile: Two Ways to Get Software Done
 One's a straight shot, like a river heading downhill, all planned out. The other is twisty, like a stream that goes with the flow.
Waterfall: The Straight Path
Waterfall is like making a rocket. You plan everything out down to the smallest screw up front, because after launch, there's no going back to change something.
It goes step by step: You figure out what you need, then you design it, build it, test it, put it out there, and keep it running. Each step needs to be done before you move on to the next. And, you take detailed notes along the way.

When Waterfall Works:

When lives are on the line, like with medical devices or plane navigation systems
When you're dealing with government rules that are set in stone
When you know exactly what you want and that isn't going to change
When you have a set budget and timeline that can't be messed with

Think about NASA creating software for a Mars rover. They can't just send updates when it's millions of miles away!
Agile: Going with the Flow
Agile is more like tending a garden. You plant seeds, watch what grows, change things as needed, and keep taking care of it.
It's all about dealing with change by using short work cycles (sprints), getting feedback from customers all the time, and having teams that can adapt fast. instead of tons of reports, you just focus on getting the software working and talking to customers.
When Agile is a Good Idea:

Startups creating stuff in markets that are always changing
Apps that need to be updated often based on what users say
Projects where you know things are going to change along the way
Teams that need to show results fast

Think of Spotify making their music app – they're always adding stuff, testing it with people, and changing direction based on what users want.

A Mix of Both
Lots of teams grab stuff from both methods. They might use Waterfall's planning for the basics, but use Agile's flexibility for new features and improvements.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
A software developer is the one who develops application, programms, and systems using various programming languages and frameworks.
* The software engineer writes code
* He or she implements software solution
* Maintains, updates, and upgrade software to ensure functionality
* Collaborates with other teams to ensure a successful project

A quality assurance engineer is the one with the responsibility of collaborating with stakeholders to explain and make them understand software requirements
# The quality assurance ensures software quality
# He or she brings and execute test plans
# Check for bugs, problems and suggests solution or correction in the project
# Confirms the software meets the taste of the stakeholders and general users before finally deployment

A project manager deals with the planning,
$ Oversees the planning,exection and delivery of software
$ Explains to the clients and software developer requirements for the project
$ Creates a blue print for the project
$ Delivers software to the client and do a regular check on its performance

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give 5 examples of each.
Integrated Development Environments (IDEs): Suites that provide tools for writing, debugging, and testing code.
Examples are; VS Code, IntelliJ IDEA,Eclipse, PyCharm, Xcode.

Version Control Systems (VCS): Tools for tracking changes to source codes and coordinating work among team members.
Examples: Git, Subversion, GitLab, Bitbucket, Github.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Some common challenges faced by software engineers
Changing requirements
Tight deadlines
Technical debts
Software security

Strategies to overcome these challenges
Effective communication
Regular reassessment of project goals and timelines
Adopt agile methodologies
Research ways to defend against hacking, malware, phishing, insider and third-party threats

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit tests
Integration tests 
System testing 
Acceptance tests 
Unit Tests: The Base
It is checking each brick before using it to build a wall. They look at the smallest parts of your software—like single functions, methods, or classes—separately.
A good unit test focuses on just one thing. Like checking if a function figures out sales tax right, or if a user's password is safe enough.
When developers write unit tests, they're saying, I'm sure this bit of code will do this exact thing in these conditions. These tests are quick (milliseconds) and run often, so you can find problems early when they're easy to fix.
Why they're important: Unit tests find small bugs before they hide in bigger, harder-to-find places. They also show how each part of the code should work.
Integration Tests: The Links
Integration tests check how the bricks work together as a wall. They make sure different pieces of code work well together.
These tests could check if your login thing works with your database or if your payment system talks to the bank correctly.
Integration tests find problems that unit tests miss, such as data problems between parts or timing issues.
Why they're important: Software can fail where parts connect. Integration tests find these problems, so your pieces work together.
System Testing: The Whole Thing
System testing looks at your whole app like a user would. It ensures the building is solid, not just the walls.
With system testing, you check that all parts work together to do what the business needs. This might be testing user sign-ups, buying stuff, or making reports.
System tests often run like the real thing, using real databases.
Why they're important: System tests confirm your software solves the problems it should. They find problems that show up when everything is used together.
Acceptance Tests: The Final Look
Acceptance tests see if your software is ready for users. It's like the final check before people move in.
These tests ensure the software meets the business needs. Stakeholders write these tests using simple terms.
Acceptance tests might check if users can do key things, if it runs fast enough, or if it can handle enough data.
Why they're important: Acceptance tests link what was built with what the business needs. They ensure you've built what users need.
The Testing Pyramid
All these tests form a pyramid: many unit tests at the bottom, a few integration tests above, and even fewer system and acceptance tests at the top. This setup gives the most safety with the least testing time.
By using all four test types, teams can find bugs early, making better software while saving money and time.
#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering 
Prompt engineering is the crafting of questions, statements to get the best possible responses from a language model.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Explain the concept of engineering
As a senior secondary school student, preparing for my finally exam in 2day's time. Vividly give a comprehensive notes not more than 10 pages on everything about engineering, including past questions with their correct solutions not exeeding the  curriulum and syllabus for Nigerian examination bodies and senior secondary schools in Nigeria.  
The latter is more concise, telling the kind of person that needs it.
The latter is clear, stating what he or she needs specifically
The latter is complete, giving all required informtion about the need of the user
